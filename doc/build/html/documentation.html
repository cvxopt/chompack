

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Documentation &mdash; Chompack 2.3.0 documentation</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  
    <link rel="top" title="Chompack 2.3.0 documentation" href="index.html"/>
        <link rel="next" title="Examples" href="examples.html"/>
        <link rel="prev" title="Installation" href="install.html"/> 

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        <a href="index.html" class="fa fa-home"> Chompack</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
        
            <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="license.html">Copyright and License</a></li>
<li class="toctree-l1"><a class="reference internal" href="install.html">Installation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="install.html#installation-from-source">Installation from source</a></li>
<li class="toctree-l2"><a class="reference internal" href="install.html#python-only-installation">Python-only installation</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Documentation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#quick-start">Quick start</a></li>
<li class="toctree-l2"><a class="reference internal" href="#symbolic-factorization">Symbolic factorization</a></li>
<li class="toctree-l2"><a class="reference internal" href="#chordal-sparse-matrices">Chordal sparse matrices</a></li>
<li class="toctree-l2"><a class="reference internal" href="#numerical-computations">Numerical computations</a></li>
<li class="toctree-l2"><a class="reference internal" href="#chordal-conversion">Chordal conversion</a></li>
<li class="toctree-l2"><a class="reference internal" href="#auxiliary-routines">Auxiliary routines</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Examples</a><ul>
<li class="toctree-l2"><a class="reference internal" href="examples.html#sdp-conversion">SDP conversion</a></li>
<li class="toctree-l2"><a class="reference internal" href="examples.html#euclidean-distance-matrix-completion">Euclidean distance matrix completion</a></li>
<li class="toctree-l2"><a class="reference internal" href="examples.html#symbolic-factorization">Symbolic factorization</a></li>
</ul>
</li>
</ul>

        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">Chompack</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>Documentation</li>
      <li class="wy-breadcrumbs-aside">
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            
  <div class="section" id="module-chompack">
<span id="documentation"></span><h1>Documentation<a class="headerlink" href="#module-chompack" title="Permalink to this headline">¶</a></h1>
<div class="section" id="quick-start">
<h2>Quick start<a class="headerlink" href="#quick-start" title="Permalink to this headline">¶</a></h2>
<p>The core functionality of CHOMPACK is contained in two types of
objects: the <a class="reference internal" href="#chompack.symbolic" title="chompack.symbolic"><code class="xref py py-class docutils literal"><span class="pre">symbolic</span></code></a> object and the <a class="reference internal" href="#chompack.cspmatrix" title="chompack.cspmatrix"><code class="xref py py-class docutils literal"><span class="pre">cspmatrix</span></code></a>
(chordal sparse matrix) object. A <a class="reference internal" href="#chompack.symbolic" title="chompack.symbolic"><code class="xref py py-class docutils literal"><span class="pre">symbolic</span></code></a> object
represents a symbolic factorization of a sparse symmetric matrix
<span class="math">\(A\)</span>, and it can be created as follows:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">cvxopt</span> <span class="k">import</span> <span class="n">spmatrix</span><span class="p">,</span> <span class="n">amd</span>
<span class="kn">import</span> <span class="nn">chompack</span> <span class="k">as</span> <span class="nn">cp</span>

<span class="c1"># generate sparse matrix</span>
<span class="n">I</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
<span class="n">J</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">spmatrix</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">7</span><span class="p">))</span>

<span class="c1"># compute symbolic factorization using AMD ordering</span>
<span class="n">symb</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">symbolic</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">amd</span><span class="o">.</span><span class="n">order</span><span class="p">)</span>
</pre></div>
</div>
<p>The argument <span class="math">\(p\)</span> is a so-called elimination order, and it can
be either an ordering routine or a permutation vector. In the above
example we used the &#8220;approximate minimum degree&#8221; (AMD) ordering
routine. Note that <span class="math">\(A\)</span> is a lower-triangular sparse matrix that represents a
symmetric matrix; upper-triangular entries in <span class="math">\(A\)</span> are ignored in the
symbolic factorization.</p>
<p>Now let&#8217;s inspect the sparsity pattern of <cite>A</cite> and its chordal
embedding (i.e., the filled pattern):</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">[</span> <span class="mf">1.00e+00</span>     <span class="mi">0</span>         <span class="mi">0</span>         <span class="mi">0</span>         <span class="mi">0</span>         <span class="mi">0</span>         <span class="mi">0</span>    <span class="p">]</span>
<span class="p">[</span> <span class="mf">1.00e+00</span>  <span class="mf">1.00e+00</span>     <span class="mi">0</span>         <span class="mi">0</span>         <span class="mi">0</span>         <span class="mi">0</span>         <span class="mi">0</span>    <span class="p">]</span>
<span class="p">[</span>    <span class="mi">0</span>         <span class="mi">0</span>      <span class="mf">1.00e+00</span>     <span class="mi">0</span>         <span class="mi">0</span>         <span class="mi">0</span>         <span class="mi">0</span>    <span class="p">]</span>
<span class="p">[</span> <span class="mf">1.00e+00</span>     <span class="mi">0</span>         <span class="mi">0</span>      <span class="mf">1.00e+00</span>     <span class="mi">0</span>         <span class="mi">0</span>         <span class="mi">0</span>    <span class="p">]</span>
<span class="p">[</span>    <span class="mi">0</span>         <span class="mi">0</span>         <span class="mi">0</span>      <span class="mf">1.00e+00</span>  <span class="mf">1.00e+00</span>     <span class="mi">0</span>         <span class="mi">0</span>    <span class="p">]</span>
<span class="p">[</span>    <span class="mi">0</span>      <span class="mf">1.00e+00</span>     <span class="mi">0</span>      <span class="mf">1.00e+00</span>  <span class="mf">1.00e+00</span>  <span class="mf">1.00e+00</span>     <span class="mi">0</span>    <span class="p">]</span>
<span class="p">[</span>    <span class="mi">0</span>         <span class="mi">0</span>      <span class="mf">1.00e+00</span>     <span class="mi">0</span>      <span class="mf">1.00e+00</span>     <span class="mi">0</span>      <span class="mf">1.00e+00</span><span class="p">]</span>
</pre></div>
</div>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">symb</span><span class="o">.</span><span class="n">sparsity_pattern</span><span class="p">(</span><span class="n">reordered</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">symmetric</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">[</span> <span class="mf">1.00e+00</span>     <span class="mi">0</span>         <span class="mi">0</span>         <span class="mi">0</span>         <span class="mi">0</span>         <span class="mi">0</span>         <span class="mi">0</span>    <span class="p">]</span>
<span class="p">[</span> <span class="mf">1.00e+00</span>  <span class="mf">1.00e+00</span>     <span class="mi">0</span>         <span class="mi">0</span>         <span class="mi">0</span>         <span class="mi">0</span>         <span class="mi">0</span>    <span class="p">]</span>
<span class="p">[</span>    <span class="mi">0</span>         <span class="mi">0</span>      <span class="mf">1.00e+00</span>     <span class="mi">0</span>         <span class="mi">0</span>         <span class="mi">0</span>         <span class="mi">0</span>    <span class="p">]</span>
<span class="p">[</span> <span class="mf">1.00e+00</span>     <span class="mi">0</span>         <span class="mi">0</span>      <span class="mf">1.00e+00</span>     <span class="mi">0</span>         <span class="mi">0</span>         <span class="mi">0</span>    <span class="p">]</span>
<span class="p">[</span>    <span class="mi">0</span>         <span class="mi">0</span>         <span class="mi">0</span>      <span class="mf">1.00e+00</span>  <span class="mf">1.00e+00</span>     <span class="mi">0</span>         <span class="mi">0</span>    <span class="p">]</span>
<span class="p">[</span> <span class="mf">1.00e+00</span>  <span class="mf">1.00e+00</span>     <span class="mi">0</span>      <span class="mf">1.00e+00</span>  <span class="mf">1.00e+00</span>  <span class="mf">1.00e+00</span>     <span class="mi">0</span>    <span class="p">]</span>
<span class="p">[</span>    <span class="mi">0</span>         <span class="mi">0</span>      <span class="mf">1.00e+00</span>     <span class="mi">0</span>      <span class="mf">1.00e+00</span>     <span class="mi">0</span>      <span class="mf">1.00e+00</span><span class="p">]</span>
</pre></div>
</div>
<p>The reordered pattern and its cliques can be inspected using the
following commands:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">symb</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">X</span> <span class="n">X</span>          <span class="p">]</span>
<span class="p">[</span><span class="n">X</span> <span class="n">X</span> <span class="n">X</span>        <span class="p">]</span>
<span class="p">[</span>  <span class="n">X</span> <span class="n">X</span>   <span class="n">X</span> <span class="n">X</span>  <span class="p">]</span>
<span class="p">[</span>      <span class="n">X</span>   <span class="n">X</span> <span class="n">X</span><span class="p">]</span>
<span class="p">[</span>    <span class="n">X</span>   <span class="n">X</span> <span class="n">X</span> <span class="n">X</span><span class="p">]</span>
<span class="p">[</span>    <span class="n">X</span> <span class="n">X</span> <span class="n">X</span> <span class="n">X</span> <span class="n">X</span><span class="p">]</span>
<span class="p">[</span>      <span class="n">X</span> <span class="n">X</span> <span class="n">X</span> <span class="n">X</span><span class="p">]</span>
</pre></div>
</div>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">symb</span><span class="o">.</span><span class="n">cliques</span><span class="p">())</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]]</span>
</pre></div>
</div>
<p>Similarly, the clique tree, the supernodes, and the separator sets are:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">symb</span><span class="o">.</span><span class="n">parent</span><span class="p">())</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
</pre></div>
</div>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">symb</span><span class="o">.</span><span class="n">supernodes</span><span class="p">())</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]]</span>
</pre></div>
</div>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">symb</span><span class="o">.</span><span class="n">separators</span><span class="p">())</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[]]</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="#chompack.cspmatrix" title="chompack.cspmatrix"><code class="xref py py-class docutils literal"><span class="pre">cspmatrix</span></code></a> object represents a chordal sparse matrix,
and it contains lower-triangular numerical values as well as a
reference to a symbolic factorization that defines the sparsity
pattern. Given a <a class="reference internal" href="#chompack.symbolic" title="chompack.symbolic"><code class="xref py py-class docutils literal"><span class="pre">symbolic</span></code></a> object <cite>symb</cite> and a sparse
matrix <span class="math">\(A\)</span>, we can create a <a class="reference internal" href="#chompack.cspmatrix" title="chompack.cspmatrix"><code class="xref py py-class docutils literal"><span class="pre">cspmatrix</span></code></a> as follows:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">cvxopt</span> <span class="k">import</span> <span class="n">spmatrix</span><span class="p">,</span> <span class="n">amd</span><span class="p">,</span> <span class="n">printing</span>
<span class="kn">import</span> <span class="nn">chompack</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="n">printing</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;dformat&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%3.1f</span><span class="s1">&#39;</span>

<span class="c1"># generate sparse matrix and compute symbolic factorization</span>
<span class="n">I</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
<span class="n">J</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">spmatrix</span><span class="p">([</span><span class="mf">1.0</span><span class="o">*</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">15</span><span class="o">+</span><span class="mi">1</span><span class="p">)],</span> <span class="n">I</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">7</span><span class="p">))</span>
<span class="n">symb</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">symbolic</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">amd</span><span class="o">.</span><span class="n">order</span><span class="p">)</span>

<span class="n">L</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">cspmatrix</span><span class="p">(</span><span class="n">symb</span><span class="p">)</span>
<span class="n">L</span> <span class="o">+=</span> <span class="n">A</span>
</pre></div>
</div>
<p>Now let us take a look at  <span class="math">\(A\)</span> and <span class="math">\(L\)</span>:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">[</span> <span class="mf">1.0</span>  <span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>  <span class="p">]</span>
<span class="p">[</span> <span class="mf">2.0</span>  <span class="mf">4.0</span>  <span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>  <span class="p">]</span>
<span class="p">[</span> <span class="mi">0</span>    <span class="mi">0</span>    <span class="mf">6.0</span>  <span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>  <span class="p">]</span>
<span class="p">[</span> <span class="mf">3.0</span>  <span class="mi">0</span>    <span class="mi">0</span>    <span class="mf">8.0</span>  <span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>  <span class="p">]</span>
<span class="p">[</span> <span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>    <span class="mf">9.0</span> <span class="mf">11.0</span>  <span class="mi">0</span>    <span class="mi">0</span>  <span class="p">]</span>
<span class="p">[</span> <span class="mi">0</span>    <span class="mf">5.0</span>  <span class="mi">0</span>   <span class="mf">10.0</span> <span class="mf">12.0</span> <span class="mf">14.0</span>  <span class="mi">0</span>  <span class="p">]</span>
<span class="p">[</span> <span class="mi">0</span>    <span class="mi">0</span>    <span class="mf">7.0</span>  <span class="mi">0</span>   <span class="mf">13.0</span>  <span class="mi">0</span>   <span class="mf">15.0</span><span class="p">]</span>
</pre></div>
</div>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">[</span> <span class="mf">6.0</span>  <span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>  <span class="p">]</span>
<span class="p">[</span> <span class="mf">7.0</span> <span class="mf">15.0</span>  <span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>  <span class="p">]</span>
<span class="p">[</span> <span class="mi">0</span>   <span class="mf">13.0</span> <span class="mf">11.0</span>  <span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>  <span class="p">]</span>
<span class="p">[</span> <span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>    <span class="mf">4.0</span>  <span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>  <span class="p">]</span>
<span class="p">[</span> <span class="mi">0</span>    <span class="mi">0</span>    <span class="mf">9.0</span>  <span class="mi">0</span>    <span class="mf">8.0</span>  <span class="mi">0</span>    <span class="mi">0</span>  <span class="p">]</span>
<span class="p">[</span> <span class="mi">0</span>    <span class="mi">0</span>   <span class="mf">12.0</span>  <span class="mf">5.0</span> <span class="mf">10.0</span> <span class="mf">14.0</span>  <span class="mi">0</span>  <span class="p">]</span>
<span class="p">[</span> <span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>    <span class="mf">2.0</span>  <span class="mf">3.0</span>  <span class="mf">0.0</span>  <span class="mf">1.0</span><span class="p">]</span>
</pre></div>
</div>
<p>Notice that <span class="math">\(L\)</span> is a reordered lower-triangular representation
of <span class="math">\(A\)</span>. We can convert <span class="math">\(L\)</span> to an <code class="xref py py-class docutils literal"><span class="pre">spmatrix</span></code> using
the <cite>spmatrix()</cite> method:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">spmatrix</span><span class="p">(</span><span class="n">reordered</span> <span class="o">=</span> <span class="kc">False</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">[</span> <span class="mf">1.0</span>  <span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>  <span class="p">]</span>
<span class="p">[</span> <span class="mf">2.0</span>  <span class="mf">4.0</span>  <span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>  <span class="p">]</span>
<span class="p">[</span> <span class="mi">0</span>    <span class="mi">0</span>    <span class="mf">6.0</span>  <span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>  <span class="p">]</span>
<span class="p">[</span> <span class="mf">3.0</span>  <span class="mi">0</span>    <span class="mi">0</span>    <span class="mf">8.0</span>  <span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>  <span class="p">]</span>
<span class="p">[</span> <span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>    <span class="mf">9.0</span> <span class="mf">11.0</span>  <span class="mi">0</span>    <span class="mi">0</span>  <span class="p">]</span>
<span class="p">[</span> <span class="mf">0.0</span>  <span class="mf">5.0</span>  <span class="mi">0</span>   <span class="mf">10.0</span> <span class="mf">12.0</span> <span class="mf">14.0</span>  <span class="mi">0</span>  <span class="p">]</span>
<span class="p">[</span> <span class="mi">0</span>    <span class="mi">0</span>    <span class="mf">7.0</span>  <span class="mi">0</span>   <span class="mf">13.0</span>  <span class="mi">0</span>   <span class="mf">15.0</span><span class="p">]</span>
</pre></div>
</div>
<p>This returns an <code class="xref py py-class docutils literal"><span class="pre">spmatrix</span></code> with the same ordering
as <span class="math">\(A\)</span>, i.e., the inverse permutation is applied to <span class="math">\(L\)</span>.</p>
<p>The following example illustrates how to use the Cholesky routine:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">cvxopt</span> <span class="k">import</span> <span class="n">spmatrix</span><span class="p">,</span> <span class="n">amd</span><span class="p">,</span> <span class="n">normal</span>
<span class="kn">from</span> <span class="nn">chompack</span> <span class="k">import</span> <span class="n">symbolic</span><span class="p">,</span> <span class="n">cspmatrix</span><span class="p">,</span> <span class="n">cholesky</span>

<span class="c1"># generate sparse matrix and compute symbolic factorization</span>
<span class="n">I</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
<span class="n">J</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">spmatrix</span><span class="p">([</span><span class="mf">0.1</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">15</span><span class="p">)],</span> <span class="n">I</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">7</span><span class="p">))</span> <span class="o">+</span> <span class="n">spmatrix</span><span class="p">(</span><span class="mf">10.0</span><span class="p">,</span><span class="nb">range</span><span class="p">(</span><span class="mi">7</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="mi">7</span><span class="p">))</span>
<span class="n">symb</span> <span class="o">=</span> <span class="n">symbolic</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">amd</span><span class="o">.</span><span class="n">order</span><span class="p">)</span>

<span class="c1"># create cspmatrix</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">cspmatrix</span><span class="p">(</span><span class="n">symb</span><span class="p">)</span>
<span class="n">L</span> <span class="o">+=</span> <span class="n">A</span>

<span class="c1"># compute numeric factorization</span>
<span class="n">cholesky</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
</pre></div>
</div>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">[</span> <span class="mf">3.3</span>  <span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>  <span class="p">]</span>
<span class="p">[</span> <span class="mf">0.2</span>  <span class="mf">3.4</span>  <span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>  <span class="p">]</span>
<span class="p">[</span> <span class="mi">0</span>    <span class="mf">0.4</span>  <span class="mf">3.3</span>  <span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>  <span class="p">]</span>
<span class="p">[</span> <span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>    <span class="mf">3.2</span>  <span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>  <span class="p">]</span>
<span class="p">[</span> <span class="mi">0</span>    <span class="mi">0</span>    <span class="mf">0.3</span>  <span class="mi">0</span>    <span class="mf">3.3</span>  <span class="mi">0</span>    <span class="mi">0</span>  <span class="p">]</span>
<span class="p">[</span> <span class="mi">0</span>    <span class="mi">0</span>    <span class="mf">0.4</span>  <span class="mf">0.2</span>  <span class="mf">0.3</span>  <span class="mf">3.3</span>  <span class="mi">0</span>  <span class="p">]</span>
<span class="p">[</span> <span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>    <span class="mf">0.1</span>  <span class="mf">0.1</span> <span class="o">-</span><span class="mf">0.0</span>  <span class="mf">3.2</span><span class="p">]</span>
</pre></div>
</div>
<p>Given a sparse matrix <span class="math">\(A\)</span>, we can check if it is chordal by
checking whether the permutation <span class="math">\(p\)</span> returned by maximum cardinality
search is a perfect elimination ordering:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">cvxopt</span> <span class="k">import</span> <span class="n">spmatrix</span><span class="p">,</span> <span class="n">printing</span>
<span class="n">printing</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="kn">import</span> <span class="nn">chompack</span> <span class="k">as</span> <span class="nn">cp</span>

<span class="c1"># Define chordal sparse matrix</span>
<span class="n">I</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">17</span><span class="p">)</span><span class="o">+</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span>\
    <span class="mi">15</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">16</span><span class="p">]</span>
<span class="n">J</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">17</span><span class="p">)</span><span class="o">+</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span>\
    <span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">15</span><span class="p">]</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">spmatrix</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">J</span><span class="p">,(</span><span class="mi">17</span><span class="p">,</span><span class="mi">17</span><span class="p">))</span>

<span class="c1"># Compute maximum cardinality search</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">maxcardsearch</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
</pre></div>
</div>
<p>Is <span class="math">\(p\)</span> a perfect elimination ordering?</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cp</span><span class="o">.</span><span class="n">peo</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">p</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kc">True</span>
</pre></div>
</div>
<p>Let&#8217;s verify that no fill is generated by the symbolic factorization:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">symb</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">symbolic</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">p</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">symb</span><span class="o">.</span><span class="n">fill</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="symbolic-factorization">
<h2>Symbolic factorization<a class="headerlink" href="#symbolic-factorization" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="chompack.symbolic">
<em class="property">class </em><code class="descclassname">chompack.</code><code class="descname">symbolic</code><span class="sig-paren">(</span><em>A</em>, <em>p=None</em>, <em>merge_function=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#chompack.symbolic" title="Permalink to this definition">¶</a></dt>
<dd><p>Symbolic factorization object.</p>
<p>Computes symbolic factorization of a square sparse matrix
<span class="math">\(A\)</span> and creates a symbolic factorization object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>A</strong> &#8211; <code class="xref py py-class docutils literal"><span class="pre">spmatrix</span></code></li>
<li><strong>p</strong> &#8211; permutation vector or ordering routine (optional)</li>
<li><strong>merge_function</strong> &#8211; routine that implements a merge heuristic (optional)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The optional argument <cite>p</cite> can be either a permutation vector or an
ordering rutine that takes an <code class="xref py py-class docutils literal"><span class="pre">spmatrix</span></code> and returns a
permutation vector.</p>
<p>The optional argument <cite>merge_function</cite> allows the user to
merge supernodes in the elimination tree in a greedy manner;
the argument must be a routine that takes the following four arguments and
returns either <cite>True</cite> or <cite>False</cite>:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>cp</strong> &#8211; clique order of the parent of clique <span class="math">\(k\)</span></li>
<li><strong>ck</strong> &#8211; clique order of clique <span class="math">\(k\)</span></li>
<li><strong>np</strong> &#8211; supernode order of the parent of supernode <span class="math">\(k\)</span></li>
<li><strong>nk</strong> &#8211; supernode order of supernode <span class="math">\(k\)</span></li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The clique k is merged with its parent if the return value is <cite>True</cite>.</p>
<dl class="attribute">
<dt id="chompack.symbolic.Nsn">
<code class="descname">Nsn</code><a class="headerlink" href="#chompack.symbolic.Nsn" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of supernodes</p>
</dd></dl>

<dl class="attribute">
<dt id="chompack.symbolic.blkptr">
<code class="descname">blkptr</code><a class="headerlink" href="#chompack.symbolic.blkptr" title="Permalink to this definition">¶</a></dt>
<dd><p>Pointer array for block storage of chordal sparse matrix.</p>
</dd></dl>

<dl class="attribute">
<dt id="chompack.symbolic.chidx">
<code class="descname">chidx</code><a class="headerlink" href="#chompack.symbolic.chidx" title="Permalink to this definition">¶</a></dt>
<dd><p>Integer array with indices of child vertices in etree: 
<cite>chidx[chptr[k]:chptr[k+1]]</cite> are the indices of the children
of supernode <span class="math">\(k\)</span>.</p>
</dd></dl>

<dl class="attribute">
<dt id="chompack.symbolic.chptr">
<code class="descname">chptr</code><a class="headerlink" href="#chompack.symbolic.chptr" title="Permalink to this definition">¶</a></dt>
<dd><p>Pointer array associated with <cite>chidx</cite>:
<cite>chidx[chptr[k]:chptr[k+1]]</cite> are the indices of the children
of supernode k.</p>
</dd></dl>

<dl class="attribute">
<dt id="chompack.symbolic.clique_number">
<code class="descname">clique_number</code><a class="headerlink" href="#chompack.symbolic.clique_number" title="Permalink to this definition">¶</a></dt>
<dd><p>The clique number (the order of the largest clique)</p>
</dd></dl>

<dl class="method">
<dt id="chompack.symbolic.cliques">
<code class="descname">cliques</code><span class="sig-paren">(</span><em>reordered=True</em><span class="sig-paren">)</span><a class="headerlink" href="#chompack.symbolic.cliques" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of cliques</p>
</dd></dl>

<dl class="attribute">
<dt id="chompack.symbolic.fill">
<code class="descname">fill</code><a class="headerlink" href="#chompack.symbolic.fill" title="Permalink to this definition">¶</a></dt>
<dd><p>Tuple with number of lower-triangular fill edges: <cite>fill[0]</cite> is
the fill due to symbolic factorization, and <cite>fill[1]</cite> is the
fill due to supernodal amalgamation</p>
</dd></dl>

<dl class="attribute">
<dt id="chompack.symbolic.ip">
<code class="descname">ip</code><a class="headerlink" href="#chompack.symbolic.ip" title="Permalink to this definition">¶</a></dt>
<dd><p>Inverse permutation vector</p>
</dd></dl>

<dl class="attribute">
<dt id="chompack.symbolic.n">
<code class="descname">n</code><a class="headerlink" href="#chompack.symbolic.n" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of nodes (matrix order)</p>
</dd></dl>

<dl class="attribute">
<dt id="chompack.symbolic.nnz">
<code class="descname">nnz</code><a class="headerlink" href="#chompack.symbolic.nnz" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of lower-triangular nonzeros.</p>
</dd></dl>

<dl class="attribute">
<dt id="chompack.symbolic.p">
<code class="descname">p</code><a class="headerlink" href="#chompack.symbolic.p" title="Permalink to this definition">¶</a></dt>
<dd><p>Permutation vector</p>
</dd></dl>

<dl class="method">
<dt id="chompack.symbolic.parent">
<code class="descname">parent</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#chompack.symbolic.parent" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a supernodal parent list: the i&#8217;th element is equal to -1 if 
supernode i is a root node in the clique forest, and otherwise
the i&#8217;th element is the index of the parent of supernode i.</p>
</dd></dl>

<dl class="attribute">
<dt id="chompack.symbolic.relidx">
<code class="descname">relidx</code><a class="headerlink" href="#chompack.symbolic.relidx" title="Permalink to this definition">¶</a></dt>
<dd><p>The relative index array facilitates fast &#8220;extend-add&#8221; and
&#8220;extract&#8221; operations in the supernodal-multifrontal
algorithms. The relative indices associated with supernode
<span class="math">\(k\)</span> is a list of indices <span class="math">\(I\)</span> such that the frontal
matrix <span class="math">\(F\)</span> associated with the parent of node <span class="math">\(k\)</span>
can be updated as <cite>F[I,I] += Uj</cite>. The relative indices are
stored in an integer array <cite>relidx</cite> with an associated pointer
array <cite>relptr</cite>.</p>
</dd></dl>

<dl class="attribute">
<dt id="chompack.symbolic.relptr">
<code class="descname">relptr</code><a class="headerlink" href="#chompack.symbolic.relptr" title="Permalink to this definition">¶</a></dt>
<dd><p>Pointer array assoicated with <cite>relidx</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="chompack.symbolic.separators">
<code class="descname">separators</code><span class="sig-paren">(</span><em>reordered=True</em><span class="sig-paren">)</span><a class="headerlink" href="#chompack.symbolic.separators" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of separator sets</p>
</dd></dl>

<dl class="attribute">
<dt id="chompack.symbolic.sncolptr">
<code class="descname">sncolptr</code><a class="headerlink" href="#chompack.symbolic.sncolptr" title="Permalink to this definition">¶</a></dt>
<dd><p>Pointer array associated with <cite>snrowidx</cite>.</p>
</dd></dl>

<dl class="attribute">
<dt id="chompack.symbolic.snode">
<code class="descname">snode</code><a class="headerlink" href="#chompack.symbolic.snode" title="Permalink to this definition">¶</a></dt>
<dd><p>Supernode array: supernode <span class="math">\(k\)</span> consists of nodes
<cite>snode[snptr[k]:snptr[k+1]]</cite> where <cite>snptr</cite> is the supernode
pointer array</p>
</dd></dl>

<dl class="attribute">
<dt id="chompack.symbolic.snpar">
<code class="descname">snpar</code><a class="headerlink" href="#chompack.symbolic.snpar" title="Permalink to this definition">¶</a></dt>
<dd><p>Supernode parent array: supernode <span class="math">\(k\)</span> is a root of the
supernodal elimination tree if <cite>snpar[k]</cite> is equal to k, and
otherwise <cite>snpar[k]</cite> is the index of the parent of supernode
<span class="math">\(k\)</span> in the supernodal elimination tree</p>
</dd></dl>

<dl class="attribute">
<dt id="chompack.symbolic.snpost">
<code class="descname">snpost</code><a class="headerlink" href="#chompack.symbolic.snpost" title="Permalink to this definition">¶</a></dt>
<dd><p>Supernode post-ordering</p>
</dd></dl>

<dl class="attribute">
<dt id="chompack.symbolic.snptr">
<code class="descname">snptr</code><a class="headerlink" href="#chompack.symbolic.snptr" title="Permalink to this definition">¶</a></dt>
<dd><p>Supernode pointer array: supernode <span class="math">\(k\)</span> is of order
<cite>snpptr[k+1]-snptr[k]</cite> and supernode <span class="math">\(k\)</span> consists of nodes
<cite>snode[snptr[k]:snptr[k+1]]</cite></p>
</dd></dl>

<dl class="attribute">
<dt id="chompack.symbolic.snrowidx">
<code class="descname">snrowidx</code><a class="headerlink" href="#chompack.symbolic.snrowidx" title="Permalink to this definition">¶</a></dt>
<dd><p>Row indices associated with representative vertices:
<cite>snrowidx[sncolptr[k]:sncolptr[k+1]]</cite> are the row indices in
the column corresponding the the representative vertex of
supernode <span class="math">\(k\)</span>, or equivalently,
<cite>snrowidx[sncolptr[k]:sncolptr[k+1]]</cite> is the <span class="math">\(k\)</span>&#8216;th
clique.</p>
</dd></dl>

<dl class="method">
<dt id="chompack.symbolic.sparsity_pattern">
<code class="descname">sparsity_pattern</code><span class="sig-paren">(</span><em>reordered=True</em>, <em>symmetric=True</em><span class="sig-paren">)</span><a class="headerlink" href="#chompack.symbolic.sparsity_pattern" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a sparse matrix with the filled pattern. By default,
the routine uses the reordered pattern, and the inverse
permutation is applied if <cite>reordered</cite> is <cite>False</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>reordered</strong> &#8211; boolean (default: <cite>True</cite>)</li>
<li><strong>symmetric</strong> &#8211; boolean (default: <cite>True</cite>)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="chompack.symbolic.supernodes">
<code class="descname">supernodes</code><span class="sig-paren">(</span><em>reordered=True</em><span class="sig-paren">)</span><a class="headerlink" href="#chompack.symbolic.supernodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of supernode sets</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="chordal-sparse-matrices">
<h2>Chordal sparse matrices<a class="headerlink" href="#chordal-sparse-matrices" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="chompack.cspmatrix">
<em class="property">class </em><code class="descclassname">chompack.</code><code class="descname">cspmatrix</code><span class="sig-paren">(</span><em>symb</em>, <em>blkval=None</em>, <em>factor=False</em><span class="sig-paren">)</span><a class="headerlink" href="#chompack.cspmatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Chordal sparse matrix object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>symb</strong> &#8211; <a class="reference internal" href="#chompack.symbolic" title="chompack.symbolic"><code class="xref py py-class docutils literal"><span class="pre">symbolic</span></code></a> object</li>
<li><strong>blkval</strong> &#8211; <code class="xref py py-class docutils literal"><span class="pre">matrix</span></code> with numerical values (optional)</li>
<li><strong>factor</strong> &#8211; boolean (default is <cite>False</cite>)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>A  <a class="reference internal" href="#chompack.cspmatrix" title="chompack.cspmatrix"><code class="xref py py-class docutils literal"><span class="pre">cspmatrix</span></code></a> object contains a reference to a symbolic
factorization as well as an array with numerical values which are
stored in a compressed block storage format which is a block variant
of the compressed column storage format.</p>
<p><cite>A = cspmatrix(symb)</cite> creates a new chordal sparse matrix object
with a sparsity pattern defined by the symbolic factorization
object <cite>symb</cite>. If the optional argument <cite>blkval</cite> specified, the
<a class="reference internal" href="#chompack.cspmatrix" title="chompack.cspmatrix"><code class="xref py py-class docutils literal"><span class="pre">cspmatrix</span></code></a> object will use the <cite>blkval</cite> array for numerical values
(and not a copy!), and otherwise the  <a class="reference internal" href="#chompack.cspmatrix" title="chompack.cspmatrix"><code class="xref py py-class docutils literal"><span class="pre">cspmatrix</span></code></a> object is
initialized with an all-zero array. The optional input <cite>factor</cite>
determines whether or not the <a class="reference internal" href="#chompack.cspmatrix" title="chompack.cspmatrix"><code class="xref py py-class docutils literal"><span class="pre">cspmatrix</span></code></a> stores a factored
matrix.</p>
<dl class="method">
<dt id="chompack.cspmatrix.add_projection">
<code class="descname">add_projection</code><span class="sig-paren">(</span><em>A</em>, <em>alpha=1.0</em>, <em>beta=1.0</em>, <em>reordered=False</em><span class="sig-paren">)</span><a class="headerlink" href="#chompack.cspmatrix.add_projection" title="Permalink to this definition">¶</a></dt>
<dd><p>Add projection of a dense matrix <span class="math">\(A\)</span> to <a class="reference internal" href="#chompack.cspmatrix" title="chompack.cspmatrix"><code class="xref py py-class docutils literal"><span class="pre">cspmatrix</span></code></a>.</p>
<blockquote>
<div>X := alpha*proj(A) + beta*X</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="chompack.cspmatrix.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#chompack.cspmatrix.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new <a class="reference internal" href="#chompack.cspmatrix" title="chompack.cspmatrix"><code class="xref py py-class docutils literal"><span class="pre">cspmatrix</span></code></a> object with a reference to the same
symbolic factorization, but with a copy of the array
that stores the numerical values.</p>
</dd></dl>

<dl class="method">
<dt id="chompack.cspmatrix.diag">
<code class="descname">diag</code><span class="sig-paren">(</span><em>reordered=True</em><span class="sig-paren">)</span><a class="headerlink" href="#chompack.cspmatrix.diag" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a vector with the diagonal elements of the matrix.</p>
</dd></dl>

<dl class="attribute">
<dt id="chompack.cspmatrix.is_factor">
<code class="descname">is_factor</code><a class="headerlink" href="#chompack.cspmatrix.is_factor" title="Permalink to this definition">¶</a></dt>
<dd><p>This property is equal to <cite>True</cite> if the cspmatrix represents a
Cholesky factor, and otherwise it is equal to <cite>False</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="chompack.cspmatrix.spmatrix">
<code class="descname">spmatrix</code><span class="sig-paren">(</span><em>reordered=True</em>, <em>symmetric=False</em><span class="sig-paren">)</span><a class="headerlink" href="#chompack.cspmatrix.spmatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts the <a class="reference internal" href="#chompack.cspmatrix" title="chompack.cspmatrix"><code class="xref py py-class docutils literal"><span class="pre">cspmatrix</span></code></a> <span class="math">\(A\)</span> to a sparse matrix. A reordered
matrix is returned if the optional argument <cite>reordered</cite> is
<cite>True</cite> (default), and otherwise the inverse permutation is applied. Only the
default options are allowed if the <a class="reference internal" href="#chompack.cspmatrix" title="chompack.cspmatrix"><code class="xref py py-class docutils literal"><span class="pre">cspmatrix</span></code></a> <span class="math">\(A\)</span> represents
a Cholesky factor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>reordered</strong> &#8211; boolean (default: True)</li>
<li><strong>symmetric</strong> &#8211; boolean (default: False)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="numerical-computations">
<h2>Numerical computations<a class="headerlink" href="#numerical-computations" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="chompack.cholesky">
<code class="descclassname">chompack.</code><code class="descname">cholesky</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#chompack.cholesky" title="Permalink to this definition">¶</a></dt>
<dd><p>Supernodal multifrontal Cholesky factorization:</p>
<div class="math">
\[X = LL^T\]</div>
<p>where <span class="math">\(L\)</span> is lower-triangular. On exit, the argument <span class="math">\(X\)</span>
contains the Cholesky factor <span class="math">\(L\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>X</strong> &#8211; <a class="reference internal" href="#chompack.cspmatrix" title="chompack.cspmatrix"><code class="xref py py-class docutils literal"><span class="pre">cspmatrix</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="chompack.llt">
<code class="descclassname">chompack.</code><code class="descname">llt</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#chompack.llt" title="Permalink to this definition">¶</a></dt>
<dd><p>Supernodal multifrontal Cholesky product:</p>
<div class="math">
\[X = LL^T\]</div>
<p>where <span class="math">\(L\)</span> is lower-triangular. On exit, the argument <cite>L</cite>
contains the product <span class="math">\(X\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>L</strong> &#8211; <a class="reference internal" href="#chompack.cspmatrix" title="chompack.cspmatrix"><code class="xref py py-class docutils literal"><span class="pre">cspmatrix</span></code></a> (factor)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="chompack.projected_inverse">
<code class="descclassname">chompack.</code><code class="descname">projected_inverse</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#chompack.projected_inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Supernodal multifrontal projected inverse. The routine computes the projected inverse</p>
<div class="math">
\[Y = P(L^{-T}L^{-1}) \]</div>
<p>where <span class="math">\(L\)</span> is a Cholesky factor. On exit, the argument <span class="math">\(L\)</span> contains the
projected inverse <span class="math">\(Y\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>L</strong> &#8211; <a class="reference internal" href="#chompack.cspmatrix" title="chompack.cspmatrix"><code class="xref py py-class docutils literal"><span class="pre">cspmatrix</span></code></a> (factor)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="chompack.completion">
<code class="descclassname">chompack.</code><code class="descname">completion</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#chompack.completion" title="Permalink to this definition">¶</a></dt>
<dd><p>Supernodal multifrontal maximum determinant positive definite
matrix completion. The routine computes the Cholesky factor
<span class="math">\(L\)</span> of the inverse of the maximum determinant positive
definite matrix completion of <span class="math">\(X\)</span>:, i.e.,</p>
<div class="math">
\[P( S^{-1} ) = X\]</div>
<p>where <span class="math">\(S = LL^T\)</span>. On exit, the argument <cite>X</cite> contains the
lower-triangular Cholesky factor <span class="math">\(L\)</span>.</p>
<p>The optional argument <cite>factored_updates</cite> can be used to enable (if
True) or disable (if False) updating of intermediate
factorizations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>X</strong> &#8211; <a class="reference internal" href="#chompack.cspmatrix" title="chompack.cspmatrix"><code class="xref py py-class docutils literal"><span class="pre">cspmatrix</span></code></a></li>
<li><strong>factored_updates</strong> &#8211; boolean</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="chompack.psdcompletion">
<code class="descclassname">chompack.</code><code class="descname">psdcompletion</code><span class="sig-paren">(</span><em>A</em>, <em>reordered=True</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#chompack.psdcompletion" title="Permalink to this definition">¶</a></dt>
<dd><p>Maximum determinant positive semidefinite matrix completion. The
routine takes a cspmatrix <span class="math">\(A\)</span> and returns the maximum determinant
positive semidefinite matrix completion <span class="math">\(X\)</span> as a dense matrix, i.e.,</p>
<div class="math">
\[P( X ) = A\]</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>A</strong> &#8211; <a class="reference internal" href="#chompack.cspmatrix" title="chompack.cspmatrix"><code class="xref py py-class docutils literal"><span class="pre">cspmatrix</span></code></a></li>
<li><strong>reordered</strong> &#8211; boolean</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="chompack.mrcompletion">
<code class="descclassname">chompack.</code><code class="descname">mrcompletion</code><span class="sig-paren">(</span><em>A</em>, <em>reordered=True</em><span class="sig-paren">)</span><a class="headerlink" href="#chompack.mrcompletion" title="Permalink to this definition">¶</a></dt>
<dd><p>Minimum rank positive semidefinite completion. The routine takes a     positive semidefinite cspmatrix <span class="math">\(A\)</span> and returns a dense
matrix <span class="math">\(Y\)</span> of size <span class="math">\(n   imes r\)</span> that satisfies</p>
<div class="math">
\[P( YY^T ) = A\]</div>
<p>where</p>
<div class="math">
\[r = \max_{i} |\gamma_i|\]</div>
<p>is the clique number (the size of the largest clique).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>A</strong> &#8211; <a class="reference internal" href="#chompack.cspmatrix" title="chompack.cspmatrix"><code class="xref py py-class docutils literal"><span class="pre">cspmatrix</span></code></a></li>
<li><strong>reordered</strong> &#8211; boolean</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="chompack.edmcompletion">
<code class="descclassname">chompack.</code><code class="descname">edmcompletion</code><span class="sig-paren">(</span><em>A</em>, <em>reordered=True</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#chompack.edmcompletion" title="Permalink to this definition">¶</a></dt>
<dd><p>Euclidean distance matrix completion. The routine takes an EDM-completable
cspmatrix <span class="math">\(A\)</span> and returns a dense EDM <span class="math">\(X\)</span>
that satisfies</p>
<div class="math">
\[P( X ) = A\]</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>A</strong> &#8211; <a class="reference internal" href="#chompack.cspmatrix" title="chompack.cspmatrix"><code class="xref py py-class docutils literal"><span class="pre">cspmatrix</span></code></a></li>
<li><strong>reordered</strong> &#8211; boolean</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="chompack.hessian">
<code class="descclassname">chompack.</code><code class="descname">hessian</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#chompack.hessian" title="Permalink to this definition">¶</a></dt>
<dd><p>Supernodal multifrontal Hessian mapping.</p>
<p>The mapping</p>
<div class="math">
\[\mathcal H_X(U) = P(X^{-1}UX^{-1}) \]</div>
<p>is the Hessian of the log-det barrier at a positive definite chordal 
matrix <span class="math">\(X\)</span>, applied to a symmetric chordal matrix <span class="math">\(U\)</span>. The Hessian operator 
can be factored as</p>
<div class="math">
\[\mathcal H_X(U) = \mathcal G_X^{\mathrm adj}( \mathcal G_X(U) ) \]</div>
<p>where the mappings on the right-hand side are adjoint mappings 
that map chordal symmetric matrices to chordal symmetric matrices.</p>
<p>This routine evaluates the mapping <span class="math">\(G_X\)</span> and its adjoint 
<span class="math">\(G_X^{\mathrm adj}\)</span> as well as the corresponding inverse 
mappings. The inputs <cite>adj</cite> and <cite>inv</cite> control the action as 
follows:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="77%" />
<col width="12%" />
<col width="11%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Action</th>
<th class="head"><cite>adj</cite></th>
<th class="head"><cite>inv</cite></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><span class="math">\(U = \mathcal G_X(U)\)</span></td>
<td>False</td>
<td>False</td>
</tr>
<tr class="row-odd"><td><span class="math">\(U = \mathcal G_X^{\mathrm adj}(U)\)</span></td>
<td>True</td>
<td>False</td>
</tr>
<tr class="row-even"><td><span class="math">\(U = \mathcal G_X^{-1}(U)\)</span></td>
<td>False</td>
<td>True</td>
</tr>
<tr class="row-odd"><td><span class="math">\(U = \mathcal (G_X^{\mathrm adj})^{-1}(U)\)</span></td>
<td>True</td>
<td>True</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>The input argument <span class="math">\(L\)</span> is the Cholesky factor of 
<span class="math">\(X\)</span>. The input argument <span class="math">\(Y\)</span> is the projected inverse of 
<span class="math">\(X\)</span>. The input argument <span class="math">\(U\)</span> is either a chordal matrix (a 
<a class="reference internal" href="#chompack.cspmatrix" title="chompack.cspmatrix"><code class="xref py py-class docutils literal"><span class="pre">cspmatrix</span></code></a>) of a list of chordal matrices with the same 
sparsity pattern as <span class="math">\(L\)</span> and <span class="math">\(Y\)</span>.</p>
<p>The optional argument <cite>factored_updates</cite> can be used to enable (if 
True) or disable (if False) updating of intermediate 
factorizations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>L</strong> &#8211; <a class="reference internal" href="#chompack.cspmatrix" title="chompack.cspmatrix"><code class="xref py py-class docutils literal"><span class="pre">cspmatrix</span></code></a> (factor)</li>
<li><strong>Y</strong> &#8211; <a class="reference internal" href="#chompack.cspmatrix" title="chompack.cspmatrix"><code class="xref py py-class docutils literal"><span class="pre">cspmatrix</span></code></a></li>
<li><strong>U</strong> &#8211; <a class="reference internal" href="#chompack.cspmatrix" title="chompack.cspmatrix"><code class="xref py py-class docutils literal"><span class="pre">cspmatrix</span></code></a> or list of <a class="reference internal" href="#chompack.cspmatrix" title="chompack.cspmatrix"><code class="xref py py-class docutils literal"><span class="pre">cspmatrix</span></code></a> objects</li>
<li><strong>adj</strong> &#8211; boolean</li>
<li><strong>inv</strong> &#8211; boolean</li>
<li><strong>factored_updates</strong> &#8211; boolean</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="chompack.dot">
<code class="descclassname">chompack.</code><code class="descname">dot</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#chompack.dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes trace product of X and Y.</p>
</dd></dl>

<dl class="function">
<dt id="chompack.trmm">
<code class="descclassname">chompack.</code><code class="descname">trmm</code><span class="sig-paren">(</span><em>L</em>, <em>B</em>, <em>alpha=1.0</em>, <em>trans='N'</em>, <em>nrhs=None</em>, <em>offsetB=0</em>, <em>ldB=None</em><span class="sig-paren">)</span><a class="headerlink" href="#chompack.trmm" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiplication with sparse triangular matrix. Computes</p>
<div class="math">
\[\begin{split}B &amp;:= \alpha L B    \text{ if trans is 'N'} \\
B &amp;:= \alpha L^T B  \text{ if trans is 'T'}\end{split}\]</div>
<p>where <span class="math">\(L\)</span> is a <a class="reference internal" href="#chompack.cspmatrix" title="chompack.cspmatrix"><code class="xref py py-class docutils literal"><span class="pre">cspmatrix</span></code></a> factor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>L</strong> &#8211; <a class="reference internal" href="#chompack.cspmatrix" title="chompack.cspmatrix"><code class="xref py py-class docutils literal"><span class="pre">cspmatrix</span></code></a> factor</li>
<li><strong>B</strong> &#8211; matrix</li>
<li><strong>alpha</strong> &#8211; float (default: 1.0)</li>
<li><strong>trans</strong> &#8211; &#8216;N&#8217; or &#8216;T&#8217; (default: &#8216;N&#8217;)</li>
<li><strong>nrhs</strong> &#8211; number of right-hand sides (default: number of columns in <span class="math">\(B\)</span>)</li>
<li><strong>offsetB</strong> &#8211; integer (default: 0)</li>
<li><strong>ldB</strong> &#8211; leading dimension of <span class="math">\(B\)</span> (default: number of rows in <span class="math">\(B\)</span>)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="chompack.trsm">
<code class="descclassname">chompack.</code><code class="descname">trsm</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#chompack.trsm" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves a triangular system of equations with multiple right-hand
sides. Computes</p>
<div class="math">
\[ \begin{align}\begin{aligned}B &amp;:= lpha L^{-1} B       ext{ if trans is 'N'}\\B &amp;:= lpha L^{-T} B       ext{ if trans is 'T'}\end{aligned}\end{align} \]</div>
<p>where <span class="math">\(L\)</span> is a <a class="reference internal" href="#chompack.cspmatrix" title="chompack.cspmatrix"><code class="xref py py-class docutils literal"><span class="pre">cspmatrix</span></code></a> factor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>L</strong> &#8211; <a class="reference internal" href="#chompack.cspmatrix" title="chompack.cspmatrix"><code class="xref py py-class docutils literal"><span class="pre">cspmatrix</span></code></a> factor</li>
<li><strong>B</strong> &#8211; matrix</li>
<li><strong>alpha</strong> &#8211; float (default: 1.0)</li>
<li><strong>trans</strong> &#8211; &#8216;N&#8217; or &#8216;T&#8217; (default: &#8216;N&#8217;)</li>
<li><strong>nrhs</strong> &#8211; number of right-hand sides (default: number of columns in <span class="math">\(B\)</span>)</li>
<li><strong>offsetB</strong> &#8211; integer (default: 0)</li>
<li><strong>ldB</strong> &#8211; leading dimension of <span class="math">\(B\)</span> (default: number of rows in <span class="math">\(B\)</span>)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="chompack.pfcholesky">
<em class="property">class </em><code class="descclassname">chompack.</code><code class="descname">pfcholesky</code><span class="sig-paren">(</span><em>X</em>, <em>V</em>, <em>a=None</em>, <em>p=None</em><span class="sig-paren">)</span><a class="headerlink" href="#chompack.pfcholesky" title="Permalink to this definition">¶</a></dt>
<dd><p>Supernodal multifrontal product-form Cholesky factorization:</p>
<div class="math">
\[X + V \mathrm{diag}(a) V^T = L_m \cdots L_1L_0 L_0^TL_1^T \cdots L_m^T\]</div>
<p>where <span class="math">\(X = L_0L_0^T\)</span> is of order n and <span class="math">\(V\)</span> is n-by-m.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>X</strong> &#8211; <a class="reference internal" href="#chompack.cspmatrix" title="chompack.cspmatrix"><code class="xref py py-class docutils literal"><span class="pre">cspmatrix</span></code></a> or <code class="xref py py-class docutils literal"><span class="pre">spmatrix</span></code></li>
<li><strong>V</strong> &#8211; n-by-m matrix</li>
<li><strong>a</strong> &#8211; m-by-1 matrix (optional, default is vector of ones)</li>
<li><strong>p</strong> &#8211; n-by-1 matrix (optional, default is natural ordering)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="chompack.pfcholesky.trmm">
<code class="descname">trmm</code><span class="sig-paren">(</span><em>B</em>, <em>trans='N'</em><span class="sig-paren">)</span><a class="headerlink" href="#chompack.pfcholesky.trmm" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiplication with product-form Cholesky factor. Computes</p>
<div class="math">
\[ \begin{align}\begin{aligned}B &amp;:= L B    \text{ if trans is 'N'}\\B &amp;:= L^T B  \text{ if trans is 'T'}\end{aligned}\end{align} \]</div>
</dd></dl>

<dl class="method">
<dt id="chompack.pfcholesky.trsm">
<code class="descname">trsm</code><span class="sig-paren">(</span><em>B</em>, <em>trans='N'</em><span class="sig-paren">)</span><a class="headerlink" href="#chompack.pfcholesky.trsm" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves a triangular system of equations with multiple righthand
sides. Computes</p>
<div class="math">
\[ \begin{align}\begin{aligned} B &amp;:= L^{-1} B  \text{ if trans is 'N'}\\B &amp;:= L^{-T} B  \text{ if trans is 'T'} \end{aligned}\end{align} \]</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="chordal-conversion">
<h2>Chordal conversion<a class="headerlink" href="#chordal-conversion" title="Permalink to this headline">¶</a></h2>
<p>The following example illustrates how to apply the chordal conversion
technique to a sparse SDP.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Given: tuple with cone LP problem data</span>
<span class="c1"># prob = (c,G,h,dims,A,b)</span>

<span class="c1"># Solve cone LP with CVXOPT&#39;s conelp() routine</span>
<span class="n">sol</span> <span class="o">=</span> <span class="n">cvxopt</span><span class="o">.</span><span class="n">conelp</span><span class="p">(</span><span class="o">*</span><span class="n">prob</span><span class="p">)</span>

<span class="c1"># Apply chordal conversion to cone LP</span>
<span class="n">probc</span><span class="p">,</span> <span class="n">blk2sparse</span><span class="p">,</span> <span class="n">symbs</span> <span class="o">=</span> <span class="n">chompack</span><span class="o">.</span><span class="n">convert_conelp</span><span class="p">(</span><span class="o">*</span><span class="n">prob</span><span class="p">)</span>

<span class="c1"># Solve converted problem with CVXOPT&#39;s conelp() routine</span>
<span class="n">solc</span> <span class="o">=</span> <span class="n">cvxopt</span><span class="o">.</span><span class="n">solvers</span><span class="o">.</span><span class="n">conelp</span><span class="p">(</span><span class="o">*</span><span class="n">probc</span><span class="p">)</span>
</pre></div>
</div>
<dl class="function">
<dt id="chompack.convert_conelp">
<code class="descclassname">chompack.</code><code class="descname">convert_conelp</code><span class="sig-paren">(</span><em>c</em>, <em>G</em>, <em>h</em>, <em>dims</em>, <em>A=None</em>, <em>b=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#chompack.convert_conelp" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies the clique conversion method of Fukuda et al. to the positive semidefinite blocks of a cone LP.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>c</strong> &#8211; <code class="xref py py-class docutils literal"><span class="pre">matrix</span></code></li>
<li><strong>G</strong> &#8211; <code class="xref py py-class docutils literal"><span class="pre">spmatrix</span></code></li>
<li><strong>h</strong> &#8211; <code class="xref py py-class docutils literal"><span class="pre">matrix</span></code></li>
<li><strong>dims</strong> &#8211; dictionary</li>
<li><strong>A</strong> &#8211; <code class="xref py py-class docutils literal"><span class="pre">spmatrix</span></code> or <code class="xref py py-class docutils literal"><span class="pre">matrix</span></code></li>
<li><strong>b</strong> &#8211; <code class="xref py py-class docutils literal"><span class="pre">matrix</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The following example illustrates how to convert a cone LP:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">prob</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">G</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">dims</span><span class="p">,</span><span class="n">A</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
<span class="n">probc</span><span class="p">,</span> <span class="n">blk2sparse</span><span class="p">,</span> <span class="n">symbs</span> <span class="o">=</span> <span class="n">convert_conelp</span><span class="p">(</span><span class="o">*</span><span class="n">prob</span><span class="p">)</span>
</pre></div>
</div>
<p>The return value <cite>blk2sparse</cite> is a list of 4-tuples
(<cite>blki,I,J,n</cite>) that each defines a mapping between the sparse
matrix representation and the converted block-diagonal
representation, and <cite>symbs</cite> is a list of symbolic factorizations
corresponding to each of the semidefinite blocks in the original cone LP.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p>M. Fukuda, M. Kojima, K. Murota, and K. Nakata, <a class="reference external" href="http://dx.doi.org/10.1137/S1052623400366218">Exploiting Sparsity
in Semidefinite Programming via Matrix Completion I: General Framework</a>,
SIAM Journal on Optimization, 11:3, 2001, pp. 647-674.</p>
<p class="last">S. Kim, M. Kojima, M. Mevissen, and M. Yamashita, <a class="reference external" href="http://dx.doi.org/10.1007/s10107-010-0402-6">Exploiting Sparsity
in Linear and Nonlinear Matrix Inequalities via Positive Semidefinite
Matrix Completion</a>,
Mathematical Programming, 129:1, 2011, pp.. 33-68.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="chompack.convert_block">
<code class="descclassname">chompack.</code><code class="descname">convert_block</code><span class="sig-paren">(</span><em>G</em>, <em>h</em>, <em>dim</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#chompack.convert_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies the clique conversion method to a single positive
semidefinite block of a cone linear program</p>
<div class="math">
\[\begin{split}\begin{array}{ll}
   \mbox{maximize}   &amp; -h^T z \\
   \mbox{subject to} &amp;  G^T z + c = 0 \\
                     &amp;  \mathbf{smat}(z)\ \ \text{psd completable}
\end{array}\end{split}\]</div>
<p>After conversion, the above problem is converted to a block-diagonal one</p>
<div class="math">
\[\begin{split}\begin{array}{ll}
   \mbox{maximize}   &amp; -h_b^T z_b  \\
   \mbox{subject to} &amp;  G_b^T z_b + c = 0 \\
                     &amp;  G_c^T z_b = 0 \\
                     &amp;  \mathbf{smat}(z_b)\ \ \text{psd block-diagonal}
\end{array}\end{split}\]</div>
<p>where <span class="math">\(z_b\)</span> is a vector representation of a block-diagonal
matrix. The constraint <span class="math">\(G_b^T z_b + c = 0\)</span> corresponds to
the original constraint <span class="math">\(G'z + c = 0\)</span>, and the constraint
<span class="math">\(G_c^T z_b = 0\)</span> is a coupling constraint.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>G</strong> &#8211; <code class="xref py py-class docutils literal"><span class="pre">spmatrix</span></code></li>
<li><strong>h</strong> &#8211; <code class="xref py py-class docutils literal"><span class="pre">matrix</span></code></li>
<li><strong>dim</strong> &#8211; integer</li>
<li><strong>merge_function</strong> &#8211; routine that implements a merge heuristic (optional)</li>
<li><strong>coupling</strong> &#8211; mode of conversion (optional)</li>
<li><strong>max_density</strong> &#8211; float (default: 0.4)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The following example illustrates how to apply the conversion method to a one-block SDP:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">block</span> <span class="o">=</span> <span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span> 
<span class="n">blockc</span><span class="p">,</span> <span class="n">blk2sparse</span><span class="p">,</span> <span class="n">symb</span> <span class="o">=</span> <span class="n">convert_block</span><span class="p">(</span><span class="o">*</span><span class="n">block</span><span class="p">)</span>
</pre></div>
</div>
<p>The return value <cite>blk2sparse</cite> is a 4-tuple
(<cite>blki,I,J,n</cite>) that defines a mapping between the sparse
matrix representation and the converted block-diagonal
representation. If <cite>blkvec</cite> represents a block-diagonal matrix,
then</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">S</span> <span class="o">=</span> <span class="n">spmatrix</span><span class="p">(</span><span class="n">blkvec</span><span class="p">[</span><span class="n">blki</span><span class="p">],</span> <span class="n">I</span><span class="p">,</span> <span class="n">J</span><span class="p">)</span> 
</pre></div>
</div>
<p>maps <cite>blkvec</cite> into is a sparse matrix representation of the
matrix. Similarly, a sparse matrix <cite>S</cite> can be converted to the
block-diagonal matrix representation using the code</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">blkvec</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">S</span><span class="p">),</span><span class="mi">1</span><span class="p">),</span> <span class="n">tc</span><span class="o">=</span><span class="n">S</span><span class="o">.</span><span class="n">typecode</span><span class="p">)</span>
<span class="n">blkvec</span><span class="p">[</span><span class="n">blki</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">V</span>
</pre></div>
</div>
<p>The optional argument <cite>max_density</cite> controls whether or not to perform
conversion based on the aggregate sparsity of the block. Specifically,
conversion is performed whenever the number of lower triangular nonzeros
in the aggregate sparsity pattern is less than or equal to <cite>max_density*dim</cite>.</p>
<p>The optional argument <cite>coupling</cite> controls the introduction
of equality constraints in the conversion. Possible values
are <em>full</em> (default), <em>sparse</em>, <em>sparse+tri</em>, and any nonnegative
integer. Full coupling results in a conversion in which all
coupling constraints are kept, and hence the converted problem is
equivalent to the original problem. Sparse coupling yeilds a
conversion in which only the coupling constraints corresponding to
nonzero entries in the aggregate sparsity pattern are kept, and
sparse-plus-tridiagonal (<em>sparse+tri</em>) yeilds a conversion with
tridiagonal coupling in addition to coupling constraints corresponding
to nonzero entries in the aggregate sparsity pattern. Setting <cite>coupling</cite>
to a nonnegative integer <em>k</em> yields a conversion with coupling
constraints corresponding to entries in a band with half-bandwidth <em>k</em>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">M. S. Andersen, A. Hansson, and L. Vandenberghe, <a class="reference external" href="http://dx.doi.org/10.1109/TPWRS.2013.2294479">Reduced-Complexity
Semidefinite Relaxations of Optimal Power Flow Problems</a>,
IEEE Transactions on Power Systems, 2014.</p>
</div>
</dd></dl>

</div>
<div class="section" id="auxiliary-routines">
<h2>Auxiliary routines<a class="headerlink" href="#auxiliary-routines" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="chompack.maxcardsearch">
<code class="descclassname">chompack.</code><code class="descname">maxcardsearch</code><span class="sig-paren">(</span><em>A</em>, <em>ve=None</em><span class="sig-paren">)</span><a class="headerlink" href="#chompack.maxcardsearch" title="Permalink to this definition">¶</a></dt>
<dd><p>Maximum cardinality search ordering of a sparse chordal matrix.</p>
<p>Returns the maximum cardinality search ordering of a symmetric
chordal matrix <span class="math">\(A\)</span>. Only the lower triangular part of
<span class="math">\(A\)</span> is accessed. The maximum cardinality search ordering
is a perfect elimination ordering in the factorization
<span class="math">\(PAP^T = LL^T\)</span>. The optional argument <cite>ve</cite> is the index of
the last vertex to be eliminated (the default value is n-1).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>A</strong> &#8211; <code class="xref py py-class docutils literal"><span class="pre">spmatrix</span></code></li>
<li><strong>ve</strong> &#8211; integer between 0 and <cite>A.size[0]</cite>-1 (optional)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="chompack.peo">
<code class="descclassname">chompack.</code><code class="descname">peo</code><span class="sig-paren">(</span><em>A</em>, <em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#chompack.peo" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether an ordering is a perfect elmimination order.</p>
<p>Returns <cite>True</cite> if the permutation <span class="math">\(p\)</span> is a perfect elimination order
for a Cholesky factorization <span class="math">\(PAP^T = LL^T\)</span>. Only the lower
triangular part of <span class="math">\(A\)</span> is accessed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>A</strong> &#8211; <code class="xref py py-class docutils literal"><span class="pre">spmatrix</span></code></li>
<li><strong>p</strong> &#8211; <code class="xref py py-class docutils literal"><span class="pre">matrix</span></code> or <code class="xref py py-class docutils literal"><span class="pre">list</span></code> of length <cite>A.size[0]</cite></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="chompack.maxchord">
<code class="descclassname">chompack.</code><code class="descname">maxchord</code><span class="sig-paren">(</span><em>A</em>, <em>ve=None</em><span class="sig-paren">)</span><a class="headerlink" href="#chompack.maxchord" title="Permalink to this definition">¶</a></dt>
<dd><p>Maximal chordal subgraph of sparsity graph.</p>
<p>Returns a lower triangular sparse matrix which is the projection
of <span class="math">\(A\)</span> on a maximal chordal subgraph and a perfect
elimination order <span class="math">\(p\)</span>. Only the
lower triangular part of <span class="math">\(A\)</span> is accessed. The
optional argument <cite>ve</cite> is the index of the last vertex to be
eliminated (the default value is <cite>n-1</cite>). If <span class="math">\(A\)</span> is chordal,
then the matrix returned is equal to <span class="math">\(A\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>A</strong> &#8211; <code class="xref py py-class docutils literal"><span class="pre">spmatrix</span></code></li>
<li><strong>ve</strong> &#8211; integer between 0 and <cite>A.size[0]</cite>-1 (optional)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">P. M. Dearing, D. R. Shier, D. D. Warner, <a class="reference external" href="http://dx.doi.org/10.1016/0166-218X(88)90075-3">Maximal chordal
subgraphs</a>,
Discrete Applied Mathematics, 20:3, 1988, pp. 181-190.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="chompack.merge_size_fill">
<code class="descclassname">chompack.</code><code class="descname">merge_size_fill</code><span class="sig-paren">(</span><em>tsize=8</em>, <em>tfill=8</em><span class="sig-paren">)</span><a class="headerlink" href="#chompack.merge_size_fill" title="Permalink to this definition">¶</a></dt>
<dd><p>Simple heuristic for supernodal amalgamation (clique
merging).</p>
<p>Returns a function that returns <cite>True</cite> if either (i) supernode k and
supernode par(k) are both of size at most <cite>tsize</cite>, or (ii),
merging supernodes par[k] and k induces at most <cite>tfill</cite> nonzeros
in the lower triangular part of the sparsity pattern.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>tsize</strong> &#8211; nonnegative integer; threshold for merging based on supernode sizes</li>
<li><strong>tfill</strong> &#8211; nonnegative integer; threshold for merging based on induced fill</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="chompack.tril">
<code class="descclassname">chompack.</code><code class="descname">tril</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#chompack.tril" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the lower triangular part of <span class="math">\(A\)</span>.</p>
</dd></dl>

<dl class="function">
<dt id="chompack.triu">
<code class="descclassname">chompack.</code><code class="descname">triu</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#chompack.triu" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the upper triangular part of <span class="math">\(A\)</span>.</p>
</dd></dl>

<dl class="function">
<dt id="chompack.perm">
<code class="descclassname">chompack.</code><code class="descname">perm</code><span class="sig-paren">(</span><em>A</em>, <em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#chompack.perm" title="Permalink to this definition">¶</a></dt>
<dd><p>Symmetric permutation of a symmetric sparse matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>A</strong> &#8211; <code class="xref py py-class docutils literal"><span class="pre">spmatrix</span></code></li>
<li><strong>p</strong> &#8211; <code class="xref py py-class docutils literal"><span class="pre">matrix</span></code> or <code class="xref py py-class docutils literal"><span class="pre">list</span></code> of length <cite>A.size[0]</cite></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="chompack.symmetrize">
<code class="descclassname">chompack.</code><code class="descname">symmetrize</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#chompack.symmetrize" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a symmetric matrix from a sparse square matrix <span class="math">\(A\)</span>. Only the
lower triangular entries of <span class="math">\(A\)</span> are accessed.</p>
</dd></dl>

<dl class="function">
<dt id="chompack.pybase.plot.spy">
<code class="descclassname">chompack.pybase.plot.</code><code class="descname">spy</code><span class="sig-paren">(</span><em>symb</em>, <em>reordered=True</em>, <em>symmetric=True</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#chompack.pybase.plot.spy" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw sparsity pattern.</p>
<p>Requires: Matplotlib, Scipy, and Numpy</p>
</dd></dl>

<dl class="function">
<dt id="chompack.pybase.plot.sparsity_graph">
<code class="descclassname">chompack.pybase.plot.</code><code class="descname">sparsity_graph</code><span class="sig-paren">(</span><em>symb</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#chompack.pybase.plot.sparsity_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw sparsity graph.</p>
<p>Requires: NetworkX and Graphviz</p>
</dd></dl>

<dl class="function">
<dt id="chompack.pybase.plot.etree_graph">
<code class="descclassname">chompack.pybase.plot.</code><code class="descname">etree_graph</code><span class="sig-paren">(</span><em>symb</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#chompack.pybase.plot.etree_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw supernodal elimination tree.</p>
<p>Requires: NetworkX and Graphviz</p>
</dd></dl>

</div>
</div>


          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="examples.html" class="btn btn-neutral float-right" title="Examples">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="install.html" class="btn btn-neutral" title="Installation"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2014-2016, Martin S. Andersen and Lieven Vandenberghe.
    </p>
  </div>

  <a href="https://github.com/snide/sphinx_rtd_theme">Sphinx theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>
</footer>
        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'2.3.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>